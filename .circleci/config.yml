version: 2.1

setup: true

orbs:
  continuation: circleci/continuation@0.2.0

jobs:
  Get_Target_Branch:
    docker:
      - image: cimg/base:stable
    resource_class: small
    steps:
      - checkout
      - run:
          name: Get Target Branch
          command: |
            if [[ -n $CIRCLE_PULL_REQUEST ]]; then
              echo $CIRCLE_PULL_REQUEST
              echo 'export GH_API_URL=$(echo $CIRCLE_PULL_REQUEST | sed "s|github.com/klsember/$CIRCLE_PROJECT_REPONAME/pull|api.github.com/repos/klsember/$CIRCLE_PROJECT_REPONAME/pulls|g")' >> $BASH_ENV
            fi
      - run: echo ${GHAPI_URL}
      - run: 
          command: |
              curl $GH_API_URL | jq '.base.ref' | tr -d '"' > Targetbranch.txt
              echo 'export TARGET_BRANCH=$(<Targetbranch.txt)' >> $BASH_ENV; source $BASH_ENV
      - run: echo 'export BASE_REVISION=$TARGET_BRANCH' >> $BASH_ENV
      - run: 
          name: Install pip
          command: |
            sudo apt-get update
            sudo apt-get install python3-pip
            pip3 install envbash
      - run: 
          environment:
            MAPPING: |
              api/.* run-api-workflow true
              app/.* run-app-workflow true
              auth/.* run-auth-workflow true
              gateway/.* run-gateway-workflow true
            OUTPUT_PATH: "/tmp/pipeline-parameters.json"
          name: Set parameters
          shell: /usr/bin/env python3
          command: |+
              #!/usr/bin/env python3
              import os
              import subprocess
              import json
              import re
              from envbash import load_envbash
              load_envbash(os.environ.get('BASH_ENV'))
              def checkout(revision):
                """
                Helper function for checking out a branch
                :param revision: The revision to checkout
                :type revision: str
                """
                subprocess.run(
                  ['git', 'checkout', revision],
                  check=True
                )
              output_path = os.environ.get('OUTPUT_PATH')
              head = os.environ.get('CIRCLE_SHA1')
              base_revision = os.environ.get('BASE_REVISION')
              checkout(base_revision)  # Checkout base revision to make sure it is available for comparison
              checkout(head)  # return to head commit
              base = subprocess.run(
                ['git', 'merge-base', base_revision, head],
                check=True,
                capture_output=True
              ).stdout.decode('utf-8').strip()
              if head == base:
                try:
                  # If building on the same branch as BASE_REVISION, we will get the
                  # current commit as merge base. In that case try to go back to the
                  # first parent, i.e. the last state of this branch before the
                  # merge, and use that as the base.
                  base = subprocess.run(
                    ['git', 'rev-parse', 'HEAD~1'], # FIXME this breaks on the first commit, fallback to something
                    check=True,
                    capture_output=True
                  ).stdout.decode('utf-8').strip()
                except:
                  # This can fail if this is the first commit of the repo, so that
                  # HEAD~1 actually doesn't resolve. In this case we can compare
                  # against this magic SHA below, which is the empty tree. The diff
                  # to that is just the first commit as patch.
                  base = '4b825dc642cb6eb9a060e54bf8d69288fbee4904'
              print('Comparing {}...{}'.format(base, head))
              changes = subprocess.run(
                ['git', 'diff', '--name-only', base, head],
                check=True,
                capture_output=True
              ).stdout.decode('utf-8').splitlines()
              mappings = [
                m.split() for m in
                os.environ.get('MAPPING').splitlines()
              ]
              def check_mapping(m):
                if 3 != len(m):
                  raise Exception("Invalid mapping")
                path, param, value = m
                regex = re.compile(r'^' + path + r'$')
                for change in changes:
                  if regex.match(change):
                    return True
                return False
              def convert_mapping(m):
                return [m[1], json.loads(m[2])]
              mappings = filter(check_mapping, mappings)
              mappings = map(convert_mapping, mappings)
              mappings = dict(mappings)
              with open(output_path, 'w') as fp:
                fp.write(json.dumps(mappings))
      - continuation/continue:
          configuration_path: .circleci/dynamic_config.yml
          circleci_domain: circleci.com
          parameters: /tmp/pipeline-parameters.json
    
workflows:
  setup:
    jobs:
      - Get_Target_Branch:
          context:
            - GitHub
